name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # Trigger on version tags like v0.1.0, v1.2.3
  workflow_dispatch:  # Allow manual trigger from GitHub UI

permissions:
  contents: write  # Required to create releases and upload assets

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
      release_upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Get version from tag
        id: tag_name
        run: |
          echo "current_version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${{ steps.tag_name.outputs.current_version }}`,
              name: `Zipy v${{ steps.tag_name.outputs.current_version }}`,
              body: 'ðŸŽ‰ Download the installer for your platform below!',
              draft: true,
              prerelease: false
            })
            return data.id

  build-tauri:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'ubuntu-22.04'
            target: 'x86_64-unknown-linux-gnu'
            bundle: 'deb'
          - platform: 'ubuntu-22.04'
            target: 'x86_64-unknown-linux-gnu'
            bundle: 'appimage'
          - platform: 'macos-latest'
            target: 'aarch64-apple-darwin'
            bundle: 'dmg'
          - platform: 'windows-latest'
            target: 'x86_64-pc-windows-msvc'
            bundle: 'nsis,msi'

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
          cache-dependency-path: 'zig-april-captions-ui/package-lock.json'

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install dependencies (Ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            libssl-dev \
            libpulse-dev

      - name: Install Zig
        uses: goto-bus-stop/setup-zig@v2
        with:
          version: 0.13.0

      - name: Install ONNX Runtime (Linux)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          wget https://github.com/microsoft/onnxruntime/releases/download/v1.16.3/onnxruntime-linux-x64-1.16.3.tgz
          tar -xzf onnxruntime-linux-x64-1.16.3.tgz
          mkdir -p ~/onnxruntime
          mv onnxruntime-linux-x64-1.16.3/* ~/onnxruntime/

      - name: Install PulseAudio (macOS)
        if: runner.os == 'macOS'
        run: brew install pulseaudio

      - name: Install ONNX Runtime (macOS)
        if: runner.os == 'macOS'
        run: |
          wget https://github.com/microsoft/onnxruntime/releases/download/v1.16.3/onnxruntime-osx-universal2-1.16.3.tgz
          tar -xzf onnxruntime-osx-universal2-1.16.3.tgz
          mkdir -p ~/onnxruntime
          mv onnxruntime-osx-universal2-1.16.3/* ~/onnxruntime/

      - name: Build zig-april-captions binary (Unix only)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          cd zig-april-captions
          mkdir -p ../zig-april-captions-ui/src-tauri/resources

          # Build with baseline CPU features for compatibility
          # -Dcpu=baseline ensures it works on all x86_64 CPUs, not just the build machine
          zig build -Doptimize=ReleaseFast -Dcpu=baseline
          # Copy binary to Tauri resources and ensure it's executable
          if [ -f "zig-out/bin/zig-april-captions" ]; then
            cp zig-out/bin/zig-april-captions ../zig-april-captions-ui/src-tauri/resources/
            chmod +x ../zig-april-captions-ui/src-tauri/resources/zig-april-captions
            echo "Binary copied and made executable"
            # Create placeholder for .exe on Unix platforms
            touch ../zig-april-captions-ui/src-tauri/resources/zig-april-captions.exe
          fi

          # Copy ONNX Runtime shared library to resources for Linux
          if [ "$RUNNER_OS" = "Linux" ]; then
            # Find and copy libonnxruntime.so
            ONNX_LIB=$(find ~/onnxruntime -name "libonnxruntime.so*" | grep -v "\.1\." | head -1)
            if [ -n "$ONNX_LIB" ]; then
              echo "Found ONNX Runtime library: $ONNX_LIB"
              cp "$ONNX_LIB" ../zig-april-captions-ui/src-tauri/resources/
              # Get the versioned library
              ONNX_VERSIONED=$(find ~/onnxruntime -name "libonnxruntime.so.[0-9]*" | head -1)
              if [ -n "$ONNX_VERSIONED" ]; then
                cp "$ONNX_VERSIONED" ../zig-april-captions-ui/src-tauri/resources/
                echo "Copied ONNX Runtime library to resources"

                # Fix rpath for deb installation
                # Zig sets absolute build paths in rpath, we need to replace with $ORIGIN
                # IMPORTANT: Patch the binary in zig-out/bin/ NOT in resources/
                # because build.rs will copy from zig-out/bin/ during Tauri build
                sudo apt-get install -y patchelf
                CURRENT_RPATH=$(patchelf --print-rpath zig-out/bin/zig-april-captions || echo "")
                echo "Current RPATH from Zig build: $CURRENT_RPATH"

                # Always set rpath to $ORIGIN for deb (removes absolute build paths)
                patchelf --set-rpath '$ORIGIN' zig-out/bin/zig-april-captions
                NEW_RPATH=$(patchelf --print-rpath zig-out/bin/zig-april-captions || echo "")
                echo "Fixed RPATH to: $NEW_RPATH"
              fi
            else
              echo "Warning: ONNX Runtime library not found"
            fi
          fi
          cd ..

      - name: Verify Linux Bundle (Debug)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          echo "=================================="
          echo "Linux Bundle Verification"
          echo "=================================="

          # 1. Check files in resources directory
          echo ""
          echo "1. Files in resources directory:"
          ls -lah zig-april-captions-ui/src-tauri/resources/

          # 2. Check binary rpath in zig-out/bin (source of truth - this is what build.rs will copy)
          echo ""
          echo "2. Binary RPATH in zig-out/bin (should be \$ORIGIN after patchelf):"
          readelf -d zig-april-captions/zig-out/bin/zig-april-captions | grep -i "rpath\|runpath" || echo "No RPATH found!"

          # 3. Check what libraries the binary needs
          echo ""
          echo "3. Binary library dependencies (from zig-out/bin):"
          ldd zig-april-captions/zig-out/bin/zig-april-captions | grep -i onnx || echo "No ONNX dependency found!"

          # 4. Verify ONNX Runtime libraries exist
          echo ""
          echo "4. Checking for ONNX Runtime libraries:"
          if [ -f "zig-april-captions-ui/src-tauri/resources/libonnxruntime.so.1.16.3" ]; then
            echo "âœ“ Found libonnxruntime.so.1.16.3"
            ls -lah zig-april-captions-ui/src-tauri/resources/libonnxruntime.so.1.16.3
          else
            echo "ERROR: libonnxruntime.so.1.16.3 not found!"
            exit 1
          fi

          # 5. Check for hardcoded paths in zig-out/bin (should not exist after patchelf)
          echo ""
          echo "5. Checking for hardcoded GitHub Actions paths in zig-out/bin (should be empty):"
          readelf -d zig-april-captions/zig-out/bin/zig-april-captions | grep -i "runner/work" && echo "ERROR: Found hardcoded GitHub Actions paths!" && exit 1 || echo "âœ“ No hardcoded paths found"

          echo ""
          echo "=================================="
          echo "âœ“ Linux Bundle Verification Passed!"
          echo "=================================="

      - name: Build zig-april-captions binary (macOS)
        if: runner.os == 'macOS'
        shell: bash
        env:
          MACOSX_DEPLOYMENT_TARGET: "10.13"
        run: |
          cd zig-april-captions
          mkdir -p ../zig-april-captions-ui/src-tauri/resources

          # Build with baseline CPU features for compatibility
          # Set deployment target to support older macOS versions
          echo "Building for macOS deployment target: $MACOSX_DEPLOYMENT_TARGET"
          zig build -Doptimize=ReleaseFast -Dcpu=baseline
          # Copy binary to Tauri resources and ensure it's executable
          if [ -f "zig-out/bin/zig-april-captions" ]; then
            cp zig-out/bin/zig-april-captions ../zig-april-captions-ui/src-tauri/resources/
            chmod +x ../zig-april-captions-ui/src-tauri/resources/zig-april-captions
            echo "Binary copied and made executable"
          fi

          # Copy ONNX Runtime shared library to resources for macOS
          ONNX_LIB=$(find ~/onnxruntime -name "libonnxruntime.dylib" | grep -v "\.1\." | head -1)
          if [ -n "$ONNX_LIB" ]; then
            echo "Found ONNX Runtime library: $ONNX_LIB"
            cp "$ONNX_LIB" ../zig-april-captions-ui/src-tauri/resources/
            # Get the versioned library
            ONNX_VERSIONED=$(find ~/onnxruntime -name "libonnxruntime.1.16.3.dylib" | head -1)
            if [ -n "$ONNX_VERSIONED" ]; then
              cp "$ONNX_VERSIONED" ../zig-april-captions-ui/src-tauri/resources/
              echo "Copied ONNX Runtime library to resources"

              # Copy PulseAudio libraries from Homebrew (required for audio capture)
              echo "Copying PulseAudio libraries from Homebrew..."
              PULSE_DIR="/opt/homebrew/opt/pulseaudio/lib"

              # Copy main PulseAudio libraries
              if [ -f "$PULSE_DIR/libpulse.0.dylib" ]; then
                cp "$PULSE_DIR/libpulse.0.dylib" ../zig-april-captions-ui/src-tauri/resources/
                echo "âœ“ Copied libpulse.0.dylib"
              else
                echo "ERROR: libpulse.0.dylib not found"
                exit 1
              fi

              if [ -f "$PULSE_DIR/libpulse-simple.0.dylib" ]; then
                cp "$PULSE_DIR/libpulse-simple.0.dylib" ../zig-april-captions-ui/src-tauri/resources/
                echo "âœ“ Copied libpulse-simple.0.dylib"
              else
                echo "ERROR: libpulse-simple.0.dylib not found"
                exit 1
              fi

              # Copy PulseAudio dependencies (if they exist)
              echo "Copying PulseAudio dependencies..."
              # Copy libpulsecommon
              for dep in "$PULSE_DIR"/libpulsecommon-*.dylib; do
                if [ -f "$dep" ]; then
                  cp "$dep" ../zig-april-captions-ui/src-tauri/resources/
                  echo "âœ“ Copied $(basename "$dep")"
                fi
              done

              # Copy libintl (gettext dependency)
              if [ -f "/opt/homebrew/opt/gettext/lib/libintl.8.dylib" ]; then
                cp "/opt/homebrew/opt/gettext/lib/libintl.8.dylib" ../zig-april-captions-ui/src-tauri/resources/
                echo "âœ“ Copied libintl.8.dylib"
              fi

              # Dynamically add all copied dylibs to tauri.conf.json frameworks array
              echo "Updating tauri.conf.json with actual dylib filenames..."
              cd ../zig-april-captions-ui/src-tauri

              # Build array of all dylib files
              DYLIB_FILES=$(ls resources/*.dylib 2>/dev/null | jq -R -s -c 'split("\n") | map(select(length > 0))')

              # Update tauri.conf.json
              jq ".bundle.macOS.frameworks = $DYLIB_FILES" tauri.conf.json > tauri.conf.json.tmp
              mv tauri.conf.json.tmp tauri.conf.json
              echo "Updated frameworks array with:"
              jq '.bundle.macOS.frameworks' tauri.conf.json
              cd ../..

              # Fix install names for ALL dylibs in resources/
              echo "Fixing dylib install names with install_name_tool..."
              for dylib in zig-april-captions-ui/src-tauri/resources/*.dylib; do
                if [ -f "$dylib" ]; then
                  DYLIBNAME=$(basename "$dylib")
                  install_name_tool -id "@rpath/$DYLIBNAME" "$dylib"
                  echo "âœ“ Fixed install name for $DYLIBNAME"
                fi
              done

              # Fix internal references in ALL dylibs to use @rpath
              echo "Fixing dylib internal references..."
              for dylib in zig-april-captions-ui/src-tauri/resources/*.dylib; do
                if [ -f "$dylib" ]; then
                  echo "Processing $(basename "$dylib")..."
                  # Get all Homebrew dependencies
                  DYLIB_REFS=$(otool -L "$dylib" | grep "/opt/homebrew" || true)
                  if [ -n "$DYLIB_REFS" ]; then
                    echo "$DYLIB_REFS" | awk '{print $1}' | while read -r lib; do
                      LIBNAME=$(basename "$lib")
                      echo "  Fixing reference to $LIBNAME..."
                      install_name_tool -change "$lib" "@rpath/$LIBNAME" "$dylib" 2>/dev/null || true
                    done
                  else
                    echo "  No /opt/homebrew references found"
                  fi
                fi
              done

              echo "Clearing and setting correct rpaths on zig-april-captions binary..."
              # IMPORTANT: Fix the binary in zig-out/bin/ NOT in resources/
              # because build.rs will copy from zig-out/bin/ during Tauri build
              # Delete all existing rpaths (Zig adds hardcoded build paths)
              # After cd ../.. we're in workspace root, so path needs zig-april-captions/ prefix
              BINARY="zig-april-captions/zig-out/bin/zig-april-captions"

              # Get all rpath entries
              RPATHS=$(otool -l "$BINARY" | grep -A 2 "LC_RPATH" | grep "path" | awk '{print $2}')

              # Delete each rpath
              for rpath in $RPATHS; do
                echo "Deleting rpath: $rpath"
                install_name_tool -delete_rpath "$rpath" "$BINARY" 2>/dev/null || true
              done

              # Add only the correct rpaths for Tauri bundle
              # Binary is at: Contents/Resources/resources/zig-april-captions
              # Frameworks are at: Contents/Frameworks/
              # So we need to go up 2 levels: ../../Frameworks
              echo "Adding correct rpaths..."
              install_name_tool -add_rpath "@loader_path" "$BINARY"
              install_name_tool -add_rpath "@executable_path/../../Frameworks" "$BINARY"
              install_name_tool -add_rpath "@executable_path" "$BINARY"

              # Fix PulseAudio library references in binary to use @rpath
              echo "Fixing PulseAudio library references in binary..."
              install_name_tool -change "/opt/homebrew/opt/pulseaudio/lib/libpulse.0.dylib" "@rpath/libpulse.0.dylib" "$BINARY" 2>/dev/null || echo "libpulse.0.dylib reference not found (may already be correct)"
              install_name_tool -change "/opt/homebrew/opt/pulseaudio/lib/libpulse-simple.0.dylib" "@rpath/libpulse-simple.0.dylib" "$BINARY" 2>/dev/null || echo "libpulse-simple.0.dylib reference not found (may already be correct)"

              # Also check for any other homebrew lib references
              echo "Checking for remaining /opt/homebrew references..."
              HOMEBREW_REFS=$(otool -L "$BINARY" | grep "/opt/homebrew" || true)
              if [ -n "$HOMEBREW_REFS" ]; then
                echo "$HOMEBREW_REFS" | awk '{print $1}' | while read -r lib; do
                  LIBNAME=$(basename "$lib")
                  echo "Fixing reference to $LIBNAME..."
                  install_name_tool -change "$lib" "@rpath/$LIBNAME" "$BINARY" 2>/dev/null || true
                done
              else
                echo "âœ“ No additional /opt/homebrew references found"
              fi

              echo "macOS dylib and binary rpath fixes applied"
            fi
          else
            echo "Warning: ONNX Runtime library not found"
          fi
          cd ..

      - name: Verify macOS Bundle (Debug)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "=================================="
          echo "macOS Bundle Verification"
          echo "=================================="

          # 1. Check files in resources directory
          echo ""
          echo "1. Files in resources directory:"
          ls -lah zig-april-captions-ui/src-tauri/resources/

          # 2. Check binary rpaths in zig-out/bin (source of truth - this is what build.rs will copy)
          echo ""
          echo "2. Binary rpaths in zig-out/bin (should include @executable_path):"
          otool -l zig-april-captions/zig-out/bin/zig-april-captions | grep -A 3 "LC_RPATH" || echo "No RPATH found!"

          # 3. Check what libraries the binary needs (from zig-out/bin)
          echo ""
          echo "3. Binary library dependencies (from zig-out/bin):"
          echo "ONNX Runtime:"
          otool -L zig-april-captions/zig-out/bin/zig-april-captions | grep -i onnx || echo "No ONNX dependency found!"
          echo "PulseAudio:"
          otool -L zig-april-captions/zig-out/bin/zig-april-captions | grep -i pulse || echo "No PulseAudio dependency found!"

          # 4. Verify PulseAudio libraries are present
          echo ""
          echo "4. Checking for PulseAudio libraries:"
          if [ -f "zig-april-captions-ui/src-tauri/resources/libpulse.0.dylib" ]; then
            echo "âœ“ Found libpulse.0.dylib"
            otool -D zig-april-captions-ui/src-tauri/resources/libpulse.0.dylib
          else
            echo "ERROR: libpulse.0.dylib not found!"
            exit 1
          fi

          if [ -f "zig-april-captions-ui/src-tauri/resources/libpulse-simple.0.dylib" ]; then
            echo "âœ“ Found libpulse-simple.0.dylib"
            otool -D zig-april-captions-ui/src-tauri/resources/libpulse-simple.0.dylib
          else
            echo "ERROR: libpulse-simple.0.dylib not found!"
            exit 1
          fi

          # 5. Check ONNX Runtime dylib install names
          echo ""
          echo "5. ONNX Runtime dylib install names (should use @rpath):"
          if [ -f "zig-april-captions-ui/src-tauri/resources/libonnxruntime.1.16.3.dylib" ]; then
            otool -D zig-april-captions-ui/src-tauri/resources/libonnxruntime.1.16.3.dylib
          else
            echo "ERROR: libonnxruntime.1.16.3.dylib not found!"
            exit 1
          fi

          if [ -f "zig-april-captions-ui/src-tauri/resources/libonnxruntime.dylib" ]; then
            otool -D zig-april-captions-ui/src-tauri/resources/libonnxruntime.dylib
          else
            echo "ERROR: libonnxruntime.dylib not found!"
            exit 1
          fi

          # 6. Check for hardcoded paths in zig-out/bin (should not exist)
          echo ""
          echo "6. Checking for hardcoded paths in zig-out/bin (should be empty):"
          echo "Checking for /opt/homebrew paths:"
          otool -L zig-april-captions/zig-out/bin/zig-april-captions | grep "/opt/homebrew" && echo "ERROR: Found hardcoded Homebrew paths!" && exit 1 || echo "âœ“ No /opt/homebrew paths"
          echo "Checking for GitHub Actions paths:"
          otool -l zig-april-captions/zig-out/bin/zig-april-captions | grep -i "runner/work" && echo "ERROR: Found hardcoded GitHub Actions paths!" && exit 1 || echo "âœ“ No GitHub Actions paths"

          # 7. Check deployment target (from zig-out/bin)
          echo ""
          echo "7. macOS Deployment Target (should be 10.13 or similar):"
          otool -l zig-april-captions/zig-out/bin/zig-april-captions | grep -A 3 "LC_VERSION_MIN_MACOSX\|LC_BUILD_VERSION" || echo "Could not determine deployment target"

          # 8. Verify rpaths contain required paths (check zig-out/bin - source of truth)
          echo ""
          echo "8. Verifying required rpaths are present in zig-out/bin:"
          RPATH_OUTPUT=$(otool -l zig-april-captions/zig-out/bin/zig-april-captions | grep -A 2 "LC_RPATH")

          if echo "$RPATH_OUTPUT" | grep -q "@executable_path/../../Frameworks"; then
            echo "âœ“ Found @executable_path/../../Frameworks"
          else
            echo "ERROR: Missing @executable_path/../../Frameworks rpath!"
            exit 1
          fi

          if echo "$RPATH_OUTPUT" | grep "@executable_path" | grep -v "Frameworks" > /dev/null; then
            echo "âœ“ Found @executable_path (for ONNX Runtime in Resources)"
          else
            echo "ERROR: Missing @executable_path rpath!"
            exit 1
          fi

          echo ""
          echo "=================================="
          echo "âœ“ macOS Bundle Verification Passed!"
          echo "=================================="

      - name: Install ONNX Runtime (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Installing ONNX Runtime for Windows..."
          Invoke-WebRequest -Uri "https://github.com/microsoft/onnxruntime/releases/download/v1.16.3/onnxruntime-win-x64-1.16.3.zip" -OutFile "onnxruntime.zip"
          Expand-Archive -Path "onnxruntime.zip" -DestinationPath "onnxruntime-temp"

          # The zip extracts to onnxruntime-win-x64-1.16.3 subdirectory
          $onnxRoot = "onnxruntime-temp\onnxruntime-win-x64-1.16.3"

          # Create onnxruntime directory structure
          New-Item -ItemType Directory -Force -Path "$env:USERPROFILE\onnxruntime\include"
          New-Item -ItemType Directory -Force -Path "$env:USERPROFILE\onnxruntime\lib"

          # Copy library files (.lib and .dll)
          Copy-Item -Path "$onnxRoot\lib\*" -Destination "$env:USERPROFILE\onnxruntime\lib" -Force

          # Copy include files - header is already named onnxruntime_c_api.h
          Copy-Item -Path "$onnxRoot\include\onnxruntime_c_api.h" -Destination "$env:USERPROFILE\onnxruntime\include\" -Force

          Write-Host "Successfully copied ONNX Runtime files"

          # Verify the files
          Write-Host "Include files:"
          Get-ChildItem -Path "$env:USERPROFILE\onnxruntime\include"
          Write-Host "Lib files:"
          Get-ChildItem -Path "$env:USERPROFILE\onnxruntime\lib"

      - name: Build zig-april-captions binary (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Building zig-april-captions for Windows with WASAPI support..."
          cd zig-april-captions
          New-Item -ItemType Directory -Force -Path "../zig-april-captions-ui/src-tauri/resources"

          # Build with baseline CPU features for compatibility
          zig build -Doptimize=ReleaseFast -Dcpu=baseline
          # Copy .exe to Tauri resources
          if (Test-Path "zig-out\bin\zig-april-captions.exe") {
            Copy-Item -Path "zig-out\bin\zig-april-captions.exe" -Destination "..\zig-april-captions-ui\src-tauri\resources\"
            Write-Host "Successfully built zig-april-captions.exe for Windows"
          } else {
            Write-Error "Failed to build zig-april-captions.exe"
            exit 1
          }

          # Copy ONNX Runtime DLL to Tauri resources (required for runtime)
          if (Test-Path "$env:USERPROFILE\onnxruntime\lib\onnxruntime.dll") {
            Copy-Item -Path "$env:USERPROFILE\onnxruntime\lib\onnxruntime.dll" -Destination "..\zig-april-captions-ui\src-tauri\resources\"
            Write-Host "Copied onnxruntime.dll to resources"
          } else {
            Write-Error "onnxruntime.dll not found in $env:USERPROFILE\onnxruntime\lib"
            exit 1
          }
          cd ..

      - name: Install frontend dependencies
        shell: bash
        run: |
          cd zig-april-captions-ui
          npm install

      - name: Verify resource files exist (Debug)
        shell: bash
        run: |
          echo "Checking for resource files..."
          ls -la zig-april-captions-ui/src-tauri/resources/ || echo "Resources directory not found!"
          pwd
          find . -name "zig-april-captions*" -type f || echo "No zig-april-captions files found"

      - name: Update tauri.conf.json to include resources
        shell: bash
        run: |
          cd zig-april-captions-ui/src-tauri
          # Use node to update tauri.conf.json
          # Different strategies for deb vs AppImage vs other platforms
          if [ "$RUNNER_OS" = "Linux" ] && [ "${{ matrix.bundle }}" = "deb" ]; then
            # For .deb: use deb.files to install binary to /usr/lib/zigy/
            # Keep resources empty to avoid conflicts
            node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('tauri.conf.json', 'utf8'));

            // Initialize linux and deb objects if they don't exist
            if (!config.bundle.linux) config.bundle.linux = {};
            if (!config.bundle.linux.deb) config.bundle.linux.deb = {};

            // Find the ONNX Runtime library file names
            const { execSync } = require('child_process');
            let onnxLibFile = null;
            let onnxVersionedFile = null;

            try {
              const files = execSync('ls resources/libonnxruntime.so* 2>/dev/null', { encoding: 'utf8' }).trim().split('\\n');
              onnxLibFile = files.find(f => f.match(/libonnxruntime\\.so$/));
              onnxVersionedFile = files.find(f => f.match(/libonnxruntime\\.so\\./));
            } catch (e) {
              console.log('No ONNX Runtime library files found');
            }

            // Use deb.files to install the binary and library directly to /usr/lib/zigy/
            // The binary uses \$ORIGIN rpath to find the library relative to itself
            const debFiles = {
              '/usr/lib/zigy/zig-april-captions': 'resources/zig-april-captions'
            };

            if (onnxLibFile) {
              debFiles['/usr/lib/zigy/libonnxruntime.so'] = onnxLibFile;
            }
            if (onnxVersionedFile) {
              const version = onnxVersionedFile.match(/libonnxruntime\\.so\\.(.+)/)[1];
              debFiles['/usr/lib/zigy/libonnxruntime.so.' + version] = onnxVersionedFile;
            }

            config.bundle.linux.deb.files = debFiles;
            // Keep resources empty for deb to avoid conflicts
            config.bundle.resources = [];

            fs.writeFileSync('tauri.conf.json', JSON.stringify(config, null, 2));
            console.log('Updated tauri.conf.json for DEB build');
            console.log('- deb.files:', JSON.stringify(config.bundle.linux.deb, null, 2));
            console.log('- resources: []');
            "
          elif [ "$RUNNER_OS" = "Linux" ] && [ "${{ matrix.bundle }}" = "appimage" ]; then
            # For AppImage: use resources to bundle binary
            # Don't use deb.files
            node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('tauri.conf.json', 'utf8'));

            // Find the ONNX Runtime library file names
            const { execSync } = require('child_process');
            let onnxLibFile = null;
            let onnxVersionedFile = null;

            try {
              const files = execSync('ls resources/libonnxruntime.so* 2>/dev/null', { encoding: 'utf8' }).trim().split('\\n');
              onnxLibFile = files.find(f => f.match(/libonnxruntime\\.so$/));
              onnxVersionedFile = files.find(f => f.match(/libonnxruntime\\.so\\./));
            } catch (e) {
              console.log('No ONNX Runtime library files found');
            }

            // Use resources to bundle everything into AppImage
            const resourceFiles = ['resources/zig-april-captions'];

            if (onnxLibFile) {
              resourceFiles.push(onnxLibFile);
            }
            if (onnxVersionedFile) {
              resourceFiles.push(onnxVersionedFile);
            }

            config.bundle.resources = resourceFiles;

            fs.writeFileSync('tauri.conf.json', JSON.stringify(config, null, 2));
            console.log('Updated tauri.conf.json for APPIMAGE build');
            console.log('- resources:', JSON.stringify(config.bundle.resources, null, 2));
            "
          elif [ "$RUNNER_OS" = "Windows" ]; then
            # Windows: use resources
            node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('tauri.conf.json', 'utf8'));
            config.bundle.resources = [
              'resources/zig-april-captions.exe',
              'resources/onnxruntime.dll'
            ];
            fs.writeFileSync('tauri.conf.json', JSON.stringify(config, null, 2));
            console.log('Updated tauri.conf.json with Windows resources');
            "
          else
            # macOS: use resources with dylib
            node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('tauri.conf.json', 'utf8'));

            // Find the ONNX Runtime library file names
            const { execSync } = require('child_process');
            let onnxLibFiles = [];

            try {
              const files = execSync('ls resources/libonnxruntime*.dylib 2>/dev/null', { encoding: 'utf8' }).trim().split('\\n');
              onnxLibFiles = files.filter(f => f.match(/libonnxruntime.*\\.dylib$/));
            } catch (e) {
              console.log('No ONNX Runtime library files found');
            }

            // Include executable and all dylib files
            config.bundle.resources = [
              'resources/zig-april-captions',
              ...onnxLibFiles
            ];

            fs.writeFileSync('tauri.conf.json', JSON.stringify(config, null, 2));
            console.log('Updated tauri.conf.json with macOS resources including dylib');
            console.log('Resources:', config.bundle.resources);
            "
          fi
          cat tauri.conf.json

      - name: Update version from git tag
        working-directory: zig-april-captions-ui
        shell: bash
        run: |
          # Extract version from git tag (e.g., v0.2.0 -> 0.2.0)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "Updating version to: $VERSION"

          # Update version in package.json
          node -e "
          const fs = require('fs');
          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          pkg.version = '$VERSION';
          fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          console.log('Updated package.json version to $VERSION');
          "

          # Update version in tauri.conf.json
          node -e "
          const fs = require('fs');
          const config = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
          config.version = '$VERSION';
          fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(config, null, 2) + '\n');
          console.log('Updated tauri.conf.json version to $VERSION');
          "

          # Verify the updates
          echo "New version in package.json:"
          cat package.json | grep -A 1 '"version"'
          echo ""
          echo "New version in tauri.conf.json:"
          cat src-tauri/tauri.conf.json | grep -A 1 '"version"'

      - name: Build Tauri App
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MACOSX_DEPLOYMENT_TARGET: "10.13"
          SKIP_ZIG_BUILD: "1"  # Prevent build.rs from rebuilding and overwriting the patched binary
        with:
          releaseId: ${{ needs.create-release.outputs.release_id }}
          args: --target ${{ matrix.target }} --bundles ${{ matrix.bundle }}
          projectPath: zig-april-captions-ui

      - name: Final Verification - Inspect DMG/App Bundle (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "=========================================="
          echo "Final DMG/App Bundle Verification (macOS)"
          echo "=========================================="

          # Find the built DMG file
          DMG_FILE=$(find zig-april-captions-ui/src-tauri/target -name "*.dmg" -type f | head -1)

          if [ -z "$DMG_FILE" ]; then
            echo "ERROR: No DMG file found!"
            exit 1
          fi

          echo "Found DMG: $DMG_FILE"
          echo ""

          # Mount the DMG
          echo "Mounting DMG..."
          MOUNT_POINT="/tmp/zigy-verify-$$"
          mkdir -p "$MOUNT_POINT"
          hdiutil attach "$DMG_FILE" -readonly -mountpoint "$MOUNT_POINT" -nobrowse

          # Find the .app bundle
          APP_BUNDLE=$(find "$MOUNT_POINT" -name "*.app" -maxdepth 1 | head -1)

          if [ -z "$APP_BUNDLE" ]; then
            echo "ERROR: No .app bundle found in DMG!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          echo "Found app bundle: $APP_BUNDLE"
          echo ""

          # Path to the binary inside the app
          BINARY="$APP_BUNDLE/Contents/Resources/resources/zig-april-captions"

          if [ ! -f "$BINARY" ]; then
            echo "ERROR: Binary not found at: $BINARY"
            echo "Contents of Resources/resources:"
            ls -la "$APP_BUNDLE/Contents/Resources/resources/" || echo "Directory not found"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          echo "1. Files in app bundle:"
          echo ""
          echo "Resources/resources:"
          ls -lah "$APP_BUNDLE/Contents/Resources/resources/" 2>/dev/null || echo "  (empty or doesn't exist)"
          echo ""
          echo "Frameworks:"
          ls -lah "$APP_BUNDLE/Contents/Frameworks/" 2>/dev/null || echo "  (empty or doesn't exist)"
          echo ""

          echo "2. Binary rpaths in final app:"
          otool -l "$BINARY" | grep -A 3 "LC_RPATH"
          echo ""

          echo "3. Binary library dependencies:"
          echo "ONNX Runtime:"
          otool -L "$BINARY" | grep -i onnx
          echo "PulseAudio:"
          otool -L "$BINARY" | grep -i pulse
          echo ""

          echo "4. Checking dylib files exist:"
          RESOURCES_PATH="$APP_BUNDLE/Contents/Resources/resources"
          FRAMEWORKS_PATH="$APP_BUNDLE/Contents/Frameworks"

          # Check ONNX Runtime (in Frameworks)
          if [ -f "$FRAMEWORKS_PATH/libonnxruntime.1.16.3.dylib" ]; then
            echo "âœ“ libonnxruntime.1.16.3.dylib exists (in Frameworks)"
            otool -D "$FRAMEWORKS_PATH/libonnxruntime.1.16.3.dylib" | tail -1
          else
            echo "ERROR: libonnxruntime.1.16.3.dylib not found in Frameworks!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          # Check PulseAudio (in Frameworks)
          if [ -f "$FRAMEWORKS_PATH/libpulse.0.dylib" ]; then
            echo "âœ“ libpulse.0.dylib exists (in Frameworks)"
            otool -D "$FRAMEWORKS_PATH/libpulse.0.dylib" | tail -1
          else
            echo "ERROR: libpulse.0.dylib not found in Frameworks!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          if [ -f "$FRAMEWORKS_PATH/libpulse-simple.0.dylib" ]; then
            echo "âœ“ libpulse-simple.0.dylib exists (in Frameworks)"
            otool -D "$FRAMEWORKS_PATH/libpulse-simple.0.dylib" | tail -1
          else
            echo "ERROR: libpulse-simple.0.dylib not found in Frameworks!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          # Check PulseAudio dependencies
          echo ""
          echo "Checking PulseAudio dependencies:"
          PULSECOMMON=$(find "$FRAMEWORKS_PATH" "$RESOURCES_PATH" 2>/dev/null -name "libpulsecommon-*.dylib" | head -1)
          if [ -n "$PULSECOMMON" ]; then
            echo "âœ“ Found $(basename "$PULSECOMMON") in $(dirname "$PULSECOMMON" | xargs basename)"
            otool -D "$PULSECOMMON" | tail -1
          else
            echo "âš  WARNING: libpulsecommon-*.dylib not found (may be statically linked into libpulse)"
          fi

          LIBINTL=$(find "$FRAMEWORKS_PATH" "$RESOURCES_PATH" 2>/dev/null -name "libintl.*.dylib" | head -1)
          if [ -n "$LIBINTL" ]; then
            echo "âœ“ Found $(basename "$LIBINTL") in $(dirname "$LIBINTL" | xargs basename)"
            otool -D "$LIBINTL" | tail -1
          else
            echo "ERROR: libintl.*.dylib not found in Frameworks or Resources!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi
          echo ""

          echo "5. Final check - No hardcoded paths:"
          echo "Checking for /opt/homebrew paths:"
          if otool -L "$BINARY" | grep "/opt/homebrew"; then
            echo "ERROR: Found hardcoded Homebrew paths in final DMG!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          else
            echo "âœ“ No /opt/homebrew paths"
          fi
          echo "Checking for GitHub Actions paths:"
          if otool -l "$BINARY" | grep -i "runner/work"; then
            echo "ERROR: Found hardcoded GitHub Actions paths in final DMG!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          else
            echo "âœ“ No hardcoded paths found"
          fi
          echo ""

          echo "6. Verify required rpaths present in final app:"
          RPATH_OUTPUT=$(otool -l "$BINARY" | grep -A 2 "LC_RPATH")

          if echo "$RPATH_OUTPUT" | grep -q "@executable_path/../../Frameworks"; then
            echo "âœ“ Found @executable_path/../../Frameworks"
          else
            echo "ERROR: Missing @executable_path/../../Frameworks in final app!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          if echo "$RPATH_OUTPUT" | grep "@executable_path" | grep -v "Frameworks" > /dev/null; then
            echo "âœ“ Found @executable_path (for ONNX Runtime in Resources)"
          else
            echo "ERROR: Missing @executable_path in final app!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          # Unmount DMG
          echo ""
          echo "Unmounting DMG..."
          hdiutil detach "$MOUNT_POINT"

          echo ""
          echo "=========================================="
          echo "âœ“ Final DMG Verification Passed!"
          echo "=========================================="

  publish-release:
    needs: [create-release, build-tauri]
    runs-on: ubuntu-latest
    steps:
      - name: Publish Release
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: ${{ needs.create-release.outputs.release_id }},
              draft: false
            })
