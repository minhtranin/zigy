name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # Trigger on version tags like v0.1.0, v1.2.3
  workflow_dispatch:  # Allow manual trigger from GitHub UI

permissions:
  contents: write  # Required to create releases and upload assets

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
      release_upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Get version from tag
        id: tag_name
        run: |
          echo "current_version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${{ steps.tag_name.outputs.current_version }}`,
              name: `Zipy v${{ steps.tag_name.outputs.current_version }}`,
              body: 'ðŸŽ‰ Download the installer for your platform below!',
              draft: true,
              prerelease: false
            })
            return data.id

  build-tauri:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'ubuntu-22.04'
            target: 'x86_64-unknown-linux-gnu'
            bundle: 'deb'
          - platform: 'ubuntu-22.04'
            target: 'x86_64-unknown-linux-gnu'
            bundle: 'appimage'
          - platform: 'macos-latest'
            target: 'aarch64-apple-darwin'
            bundle: 'dmg'
          - platform: 'windows-latest'
            target: 'x86_64-pc-windows-msvc'
            bundle: 'nsis,msi'

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
          cache-dependency-path: 'zig-april-captions-ui/package-lock.json'

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install dependencies (Ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            libssl-dev \
            libpulse-dev

      - name: Install Zig
        uses: goto-bus-stop/setup-zig@v2
        with:
          version: 0.13.0

      - name: Install ONNX Runtime (Linux)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          wget https://github.com/microsoft/onnxruntime/releases/download/v1.16.3/onnxruntime-linux-x64-1.16.3.tgz
          tar -xzf onnxruntime-linux-x64-1.16.3.tgz
          mkdir -p ~/onnxruntime
          mv onnxruntime-linux-x64-1.16.3/* ~/onnxruntime/

      - name: Install ONNX Runtime (macOS)
        if: runner.os == 'macOS'
        run: |
          wget https://github.com/microsoft/onnxruntime/releases/download/v1.16.3/onnxruntime-osx-universal2-1.16.3.tgz
          tar -xzf onnxruntime-osx-universal2-1.16.3.tgz
          mkdir -p ~/onnxruntime
          mv onnxruntime-osx-universal2-1.16.3/* ~/onnxruntime/

      - name: Build zig-april-captions binary (Linux only)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          cd zig-april-captions
          mkdir -p ../zig-april-captions-ui/src-tauri/resources

          # Build with baseline CPU features for compatibility
          # -Dcpu=baseline ensures it works on all x86_64 CPUs, not just the build machine
          zig build -Doptimize=ReleaseFast -Dcpu=baseline
          # Copy binary to Tauri resources and ensure it's executable
          if [ -f "zig-out/bin/zig-april-captions" ]; then
            cp zig-out/bin/zig-april-captions ../zig-april-captions-ui/src-tauri/resources/
            chmod +x ../zig-april-captions-ui/src-tauri/resources/zig-april-captions
            echo "Binary copied and made executable"
            # Create placeholder for .exe on Unix platforms
            touch ../zig-april-captions-ui/src-tauri/resources/zig-april-captions.exe
          fi

          # Copy ONNX Runtime shared library to resources for Linux
          if [ "$RUNNER_OS" = "Linux" ]; then
            # Find and copy libonnxruntime.so
            ONNX_LIB=$(find ~/onnxruntime -name "libonnxruntime.so*" | grep -v "\.1\." | head -1)
            if [ -n "$ONNX_LIB" ]; then
              echo "Found ONNX Runtime library: $ONNX_LIB"
              cp "$ONNX_LIB" ../zig-april-captions-ui/src-tauri/resources/
              # Get the versioned library
              ONNX_VERSIONED=$(find ~/onnxruntime -name "libonnxruntime.so.[0-9]*" | head -1)
              if [ -n "$ONNX_VERSIONED" ]; then
                cp "$ONNX_VERSIONED" ../zig-april-captions-ui/src-tauri/resources/
                echo "Copied ONNX Runtime library to resources"

                # Download April ASR model for testing and bundling
                echo "Downloading April ASR model..."
                MODEL_NAME="april-english-dev-01110_en.april"
                MODEL_URL="https://april.sapples.net/$MODEL_NAME"
                MODEL_PATH="../zig-april-captions-ui/src-tauri/resources/$MODEL_NAME"

                if [ ! -f "$MODEL_PATH" ]; then
                  curl -L -o "$MODEL_PATH" "$MODEL_URL"
                  echo "âœ“ Downloaded model: $MODEL_NAME"
                else
                  echo "âœ“ Model already exists: $MODEL_NAME"
                fi

                # Fix rpath for deb installation
                # Zig sets absolute build paths in rpath, we need to replace with $ORIGIN
                # IMPORTANT: Patch the binary in zig-out/bin/ NOT in resources/
                # because build.rs will copy from zig-out/bin/ during Tauri build
                sudo apt-get install -y patchelf
                CURRENT_RPATH=$(patchelf --print-rpath zig-out/bin/zig-april-captions || echo "")
                echo "Current RPATH from Zig build: $CURRENT_RPATH"

                # Set rpath based on bundle type
                # DEB: libraries in same dir as binary -> $ORIGIN
                # AppImage: libraries in resources/ -> $ORIGIN:$ORIGIN/resources
                if [ "${{ matrix.bundle }}" = "deb" ]; then
                  patchelf --set-rpath '$ORIGIN' zig-out/bin/zig-april-captions
                  echo "Set RPATH to \$ORIGIN for DEB (libraries in same dir)"
                else
                  patchelf --set-rpath '$ORIGIN:$ORIGIN/resources' zig-out/bin/zig-april-captions
                  echo "Set RPATH to \$ORIGIN:\$ORIGIN/resources for AppImage"
                fi
                NEW_RPATH=$(patchelf --print-rpath zig-out/bin/zig-april-captions || echo "")
                echo "Fixed RPATH to: $NEW_RPATH"

                # NOTE: Not bundling PulseAudio libraries
                # Using system PulseAudio ensures best compatibility
                # and proper buffer negotiation with user's audio server
              fi
            else
              echo "Warning: ONNX Runtime library not found"
            fi
          fi
          cd ..

      - name: Test zig-april-captions binary (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          echo "=================================="
          echo "Testing zig-april-captions binary"
          echo "=================================="

          BINARY="zig-april-captions-ui/src-tauri/resources/zig-april-captions"
          MODEL="zig-april-captions-ui/src-tauri/resources/april-english-dev-01110_en.april"

          if [ ! -f "$BINARY" ]; then
            echo "ERROR: Binary not found at $BINARY"
            exit 1
          fi

          if [ ! -f "$MODEL" ]; then
            echo "ERROR: Model not found at $MODEL"
            exit 1
          fi

          echo "Binary: $BINARY"
          echo "Model: $MODEL"
          echo ""

          # Check binary dependencies
          echo "Test 1: Check library dependencies"
          ldd "$BINARY" | grep -i onnx || echo "No ONNX dependency found"

          # Test: Try to load the model (will fail without audio, but tests library loading)
          # Using background process with timeout for cross-platform compatibility
          echo ""
          echo "Test 2: Load model (tests dylib/so loading)"
          ("$BINARY" --json "$MODEL" 2>&1 || true) | head -20 &
          TEST_PID=$!
          sleep 5
          kill $TEST_PID 2>/dev/null || true
          wait $TEST_PID 2>/dev/null || true

          echo ""
          echo "âœ“ Binary test completed"
          echo "Note: Full speech recognition test requires audio input (not available in CI)"

      - name: Verify Linux Bundle (Debug)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          echo "=================================="
          echo "Linux Bundle Verification"
          echo "=================================="

          # 1. Check files in resources directory
          echo ""
          echo "1. Files in resources directory:"
          ls -lah zig-april-captions-ui/src-tauri/resources/

          # 2. Check binary rpath in zig-out/bin (source of truth - this is what build.rs will copy)
          echo ""
          echo "2. Binary RPATH in zig-out/bin (should be \$ORIGIN after patchelf):"
          readelf -d zig-april-captions/zig-out/bin/zig-april-captions | grep -i "rpath\|runpath" || echo "No RPATH found!"

          # 3. Check what libraries the binary needs
          echo ""
          echo "3. Binary library dependencies (from zig-out/bin):"
          ldd zig-april-captions/zig-out/bin/zig-april-captions | grep -i onnx || echo "No ONNX dependency found!"

          # 4. Verify ONNX Runtime libraries exist
          echo ""
          echo "4. Checking for ONNX Runtime libraries:"
          if [ -f "zig-april-captions-ui/src-tauri/resources/libonnxruntime.so.1.16.3" ]; then
            echo "âœ“ Found libonnxruntime.so.1.16.3"
            ls -lah zig-april-captions-ui/src-tauri/resources/libonnxruntime.so.1.16.3
          else
            echo "ERROR: libonnxruntime.so.1.16.3 not found!"
            exit 1
          fi

          # 5. Check for hardcoded paths in zig-out/bin (should not exist after patchelf)
          echo ""
          echo "5. Checking for hardcoded GitHub Actions paths in zig-out/bin (should be empty):"
          readelf -d zig-april-captions/zig-out/bin/zig-april-captions | grep -i "runner/work" && echo "ERROR: Found hardcoded GitHub Actions paths!" && exit 1 || echo "âœ“ No hardcoded paths found"

          echo ""
          echo "=================================="
          echo "âœ“ Linux Bundle Verification Passed!"
          echo "=================================="

      - name: Build zig-april-captions binary (macOS)
        if: runner.os == 'macOS'
        shell: bash
        env:
          MACOSX_DEPLOYMENT_TARGET: "10.13"
        run: |
          cd zig-april-captions
          mkdir -p ../zig-april-captions-ui/src-tauri/resources

          # Build with baseline CPU features for compatibility
          # Set deployment target to support older macOS versions
          echo "Building for macOS deployment target: $MACOSX_DEPLOYMENT_TARGET"
          zig build -Doptimize=ReleaseFast -Dcpu=baseline

          # Fix rpaths on the built binary BEFORE copying
          # Clear development rpaths FIRST to free up space in binary header
          install_name_tool -delete_rpath /opt/homebrew/lib zig-out/bin/zig-april-captions 2>/dev/null || true
          install_name_tool -delete_rpath /Users/runner/onnxruntime/lib zig-out/bin/zig-april-captions 2>/dev/null || true
          echo "âœ“ Removed development rpaths from build output"

          # Set production rpaths for macOS app bundle
          install_name_tool -add_rpath @executable_path/../../Frameworks zig-out/bin/zig-april-captions
          install_name_tool -add_rpath @executable_path zig-out/bin/zig-april-captions
          echo "âœ“ Set production rpaths on build output"

          # Copy binary to Tauri resources and ensure it's executable
          if [ -f "zig-out/bin/zig-april-captions" ]; then
            cp zig-out/bin/zig-april-captions ../zig-april-captions-ui/src-tauri/resources/
            chmod +x ../zig-april-captions-ui/src-tauri/resources/zig-april-captions
            echo "Binary copied and made executable"
          fi

          # Copy ONNX Runtime shared library to resources for macOS
          ONNX_LIB=$(find ~/onnxruntime -name "libonnxruntime.dylib" | grep -v "\.1\." | head -1)
          if [ -n "$ONNX_LIB" ]; then
            echo "Found ONNX Runtime library: $ONNX_LIB"
            cp "$ONNX_LIB" ../zig-april-captions-ui/src-tauri/resources/
            # Get the versioned library
            ONNX_VERSIONED=$(find ~/onnxruntime -name "libonnxruntime.1.16.3.dylib" | head -1)
            if [ -n "$ONNX_VERSIONED" ]; then
              cp "$ONNX_VERSIONED" ../zig-april-captions-ui/src-tauri/resources/
              echo "Copied ONNX Runtime library to resources"

              # Download April ASR model for testing and bundling
              echo "Downloading April ASR model..."
              MODEL_NAME="april-english-dev-01110_en.april"
              MODEL_URL="https://april.sapples.net/$MODEL_NAME"
              MODEL_PATH="../zig-april-captions-ui/src-tauri/resources/$MODEL_NAME"

              if [ ! -f "$MODEL_PATH" ]; then
                curl -L -o "$MODEL_PATH" "$MODEL_URL"
                echo "âœ“ Downloaded model: $MODEL_NAME"
              else
                echo "âœ“ Model already exists: $MODEL_NAME"
              fi

              # Copy libiomp5.dylib (Intel OpenMP - required by ONNX Runtime)
              echo "Copying libiomp5.dylib (Intel OpenMP)..."
              IOMP5=""
              for dir in /opt/homebrew/Cellar/libiomp /opt/homebrew/opt/libiomp ~/onnxruntime; do
                if [ -d "$dir" ]; then
                  FOUND=$(find "$dir" -name "libiomp5.dylib" 2>/dev/null || true)
                  if [ -n "$FOUND" ]; then
                    IOMP5="$FOUND"
                    break
                  fi
                fi
              done

              if [ -n "$IOMP5" ]; then
                cp "$IOMP5" ../zig-april-captions-ui/src-tauri/resources/
                echo "âœ“ Copied libiomp5.dylib from $(dirname "$IOMP5")"
              else
                echo "âš  Warning: libiomp5.dylib not found (may be built into ONNX Runtime)"
              fi

              echo "macOS: Using CoreAudio (native), no PulseAudio libraries needed"
            fi
          else
            echo "Warning: ONNX Runtime library not found"
          fi
          cd ..

      - name: Codesign zig-april-captions binary with audio entitlements (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "=================================="
          echo "Codesigning zig-april-captions binary"
          echo "=================================="

          BINARY="zig-april-captions-ui/src-tauri/resources/zig-april-captions"
          ENTITLEMENTS="zig-april-captions-ui/src-tauri/entitlements.plist"

          if [ ! -f "$BINARY" ]; then
            echo "ERROR: Binary not found at $BINARY"
            exit 1
          fi

          if [ ! -f "$ENTITLEMENTS" ]; then
            echo "ERROR: Entitlements not found at $ENTITLEMENTS"
            exit 1
          fi

          echo "Binary: $BINARY"
          echo "Entitlements: $ENTITLEMENTS"
          echo ""

          # Display entitlements being applied
          echo "Entitlements content:"
          cat "$ENTITLEMENTS"
          echo ""

          # Codesign with entitlements and hardened runtime
          # CRITICAL: This is required for macOS to allow microphone access
          # Without this signing, the binary cannot access audio devices and
          # will fail with kAudioHardwareBadObjectError (2003332927)
          echo "Signing binary with entitlements..."
          codesign --sign - \
            --entitlements "$ENTITLEMENTS" \
            --options=runtime \
            --force \
            --deep \
            "$BINARY"

          echo ""
          echo "Verifying signature..."
          codesign -dv --verbose=4 "$BINARY" 2>&1 | head -20

          echo ""
          echo "Verifying entitlements were applied..."
          codesign -d --entitlements - "$BINARY" 2>&1 | head -30

          echo ""
          echo "âœ“ Binary codesigned with audio entitlements"

      - name: Test zig-april-captions binary (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "=================================="
          echo "Testing zig-april-captions binary"
          echo "=================================="

          BINARY="zig-april-captions-ui/src-tauri/resources/zig-april-captions"
          MODEL="zig-april-captions-ui/src-tauri/resources/april-english-dev-01110_en.april"

          if [ ! -f "$BINARY" ]; then
            echo "ERROR: Binary not found at $BINARY"
            exit 1
          fi

          if [ ! -f "$MODEL" ]; then
            echo "ERROR: Model not found at $MODEL"
            exit 1
          fi

          echo "Binary: $BINARY"
          echo "Model: $MODEL"
          echo ""

          # Test: Try to load the model (will fail without audio, but tests library loading)
          # Using background process with timeout for cross-platform compatibility
          echo "Test 1: Load model (tests dylib loading)"
          ("$BINARY" --json --verbose "$MODEL" 2>&1 || true) | head -30 &
          TEST_PID=$!
          sleep 5
          kill $TEST_PID 2>/dev/null || true
          wait $TEST_PID 2>/dev/null || true

          echo ""
          echo "âœ“ Binary test completed"
          echo "Note: Full speech recognition test requires audio input (not available in CI)"

      - name: Verify macOS Bundle (Debug)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "=================================="
          echo "macOS Bundle Verification"
          echo "=================================="

          # 1. Check files in resources directory
          echo ""
          echo "1. Files in resources directory:"
          ls -lah zig-april-captions-ui/src-tauri/resources/

          # 2. Check binary rpaths in zig-out/bin (source of truth - this is what build.rs will copy)
          echo ""
          echo "2. Binary rpaths in zig-out/bin (should include @executable_path):"
          otool -l zig-april-captions/zig-out/bin/zig-april-captions | grep -A 3 "LC_RPATH" || echo "No RPATH found!"

          # 3. Check what libraries the binary needs (from zig-out/bin)
          echo ""
          echo "3. Binary library dependencies (from zig-out/bin):"
          echo "ONNX Runtime:"
          otool -L zig-april-captions/zig-out/bin/zig-april-captions | grep -i onnx || echo "No ONNX dependency found!"
          echo "CoreAudio:"
          otool -L zig-april-captions/zig-out/bin/zig-april-captions | grep -i "AudioToolbox\|CoreAudio" || echo "CoreAudio frameworks found (system)"

          # 4. Check ONNX Runtime dylib install names
          echo ""
          echo "4. ONNX Runtime dylib install names (should use @rpath):"
          if [ -f "zig-april-captions-ui/src-tauri/resources/libonnxruntime.1.16.3.dylib" ]; then
            echo "âœ“ Found libonnxruntime.1.16.3.dylib"
            otool -D zig-april-captions-ui/src-tauri/resources/libonnxruntime.1.16.3.dylib
          else
            echo "ERROR: libonnxruntime.1.16.3.dylib not found!"
            exit 1
          fi

          if [ -f "zig-april-captions-ui/src-tauri/resources/libonnxruntime.dylib" ]; then
            echo "âœ“ Found libonnxruntime.dylib"
            otool -D zig-april-captions-ui/src-tauri/resources/libonnxruntime.dylib
          else
            echo "ERROR: libonnxruntime.dylib not found!"
            exit 1
          fi

          # 5. Check for hardcoded paths in zig-out/bin (should not exist)
          echo ""
          echo "6. Checking for hardcoded paths in zig-out/bin (should be empty):"
          echo "Checking for /opt/homebrew paths:"
          otool -L zig-april-captions/zig-out/bin/zig-april-captions | grep "/opt/homebrew" && echo "ERROR: Found hardcoded Homebrew paths!" && exit 1 || echo "âœ“ No /opt/homebrew paths"
          echo "Checking for GitHub Actions paths:"
          otool -l zig-april-captions/zig-out/bin/zig-april-captions | grep -i "runner/work" && echo "ERROR: Found hardcoded GitHub Actions paths!" && exit 1 || echo "âœ“ No GitHub Actions paths"

          # 7. Check deployment target (from zig-out/bin)
          echo ""
          echo "7. macOS Deployment Target (should be 10.13 or similar):"
          otool -l zig-april-captions/zig-out/bin/zig-april-captions | grep -A 3 "LC_VERSION_MIN_MACOSX\|LC_BUILD_VERSION" || echo "Could not determine deployment target"

          # 8. Verify rpaths contain required paths (check zig-out/bin - source of truth)
          echo ""
          echo "8. Verifying required rpaths are present in zig-out/bin:"
          RPATH_OUTPUT=$(otool -l zig-april-captions/zig-out/bin/zig-april-captions | grep -A 2 "LC_RPATH")

          if echo "$RPATH_OUTPUT" | grep -q "@executable_path/../../Frameworks"; then
            echo "âœ“ Found @executable_path/../../Frameworks"
          else
            echo "ERROR: Missing @executable_path/../../Frameworks rpath!"
            exit 1
          fi

          if echo "$RPATH_OUTPUT" | grep "@executable_path" | grep -v "Frameworks" > /dev/null; then
            echo "âœ“ Found @executable_path (for ONNX Runtime in Resources)"
          else
            echo "ERROR: Missing @executable_path rpath!"
            exit 1
          fi

          echo ""
          echo "=================================="
          echo "âœ“ macOS Bundle Verification Passed!"
          echo "=================================="

      - name: Install ONNX Runtime (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Installing ONNX Runtime for Windows..."
          Invoke-WebRequest -Uri "https://github.com/microsoft/onnxruntime/releases/download/v1.16.3/onnxruntime-win-x64-1.16.3.zip" -OutFile "onnxruntime.zip"
          Expand-Archive -Path "onnxruntime.zip" -DestinationPath "onnxruntime-temp"

          # The zip extracts to onnxruntime-win-x64-1.16.3 subdirectory
          $onnxRoot = "onnxruntime-temp\onnxruntime-win-x64-1.16.3"

          # Create onnxruntime directory structure
          New-Item -ItemType Directory -Force -Path "$env:USERPROFILE\onnxruntime\include"
          New-Item -ItemType Directory -Force -Path "$env:USERPROFILE\onnxruntime\lib"

          # Copy library files (.lib and .dll)
          Copy-Item -Path "$onnxRoot\lib\*" -Destination "$env:USERPROFILE\onnxruntime\lib" -Force

          # Copy include files - header is already named onnxruntime_c_api.h
          Copy-Item -Path "$onnxRoot\include\onnxruntime_c_api.h" -Destination "$env:USERPROFILE\onnxruntime\include\" -Force

          Write-Host "Successfully copied ONNX Runtime files"

          # Verify the files
          Write-Host "Include files:"
          Get-ChildItem -Path "$env:USERPROFILE\onnxruntime\include"
          Write-Host "Lib files:"
          Get-ChildItem -Path "$env:USERPROFILE\onnxruntime\lib"

      - name: Build zig-april-captions binary (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Building zig-april-captions for Windows with WASAPI support..."
          cd zig-april-captions
          New-Item -ItemType Directory -Force -Path "../zig-april-captions-ui/src-tauri/resources"

          # Build with baseline CPU features for compatibility
          zig build -Doptimize=ReleaseFast -Dcpu=baseline
          # Copy .exe to Tauri resources
          if (Test-Path "zig-out\bin\zig-april-captions.exe") {
            Copy-Item -Path "zig-out\bin\zig-april-captions.exe" -Destination "..\zig-april-captions-ui\src-tauri\resources\"
            Write-Host "Successfully built zig-april-captions.exe for Windows"
          } else {
            Write-Error "Failed to build zig-april-captions.exe"
            exit 1
          }

          # Copy ONNX Runtime DLL to Tauri resources (required for runtime)
          if (Test-Path "$env:USERPROFILE\onnxruntime\lib\onnxruntime.dll") {
            Copy-Item -Path "$env:USERPROFILE\onnxruntime\lib\onnxruntime.dll" -Destination "..\zig-april-captions-ui\src-tauri\resources\"
            Write-Host "Copied onnxruntime.dll to resources"
          } else {
            Write-Error "onnxruntime.dll not found in $env:USERPROFILE\onnxruntime\lib"
            exit 1
          }
          cd ..

      - name: Install frontend dependencies
        shell: bash
        run: |
          cd zig-april-captions-ui
          npm install

      - name: Verify resource files exist (Debug)
        shell: bash
        run: |
          echo "Checking for resource files..."
          ls -la zig-april-captions-ui/src-tauri/resources/ || echo "Resources directory not found!"
          pwd
          find . -name "zig-april-captions*" -type f || echo "No zig-april-captions files found"

      - name: Update tauri.conf.json to include resources
        shell: bash
        run: |
          cd zig-april-captions-ui/src-tauri
          # Use node to update tauri.conf.json
          # Different strategies for deb vs AppImage vs other platforms
          if [ "$RUNNER_OS" = "Linux" ] && [ "${{ matrix.bundle }}" = "deb" ]; then
            # For .deb: use deb.files to install binary and ALL libraries to /usr/lib/zigy/
            # Including the model (321MB) and ALL PulseAudio dependencies
            node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('tauri.conf.json', 'utf8'));

            // Initialize linux and deb objects if they don't exist
            if (!config.bundle.linux) config.bundle.linux = {};
            if (!config.bundle.linux.deb) config.bundle.linux.deb = {};

            // Find the ONNX Runtime library file names
            const { execSync } = require('child_process');
            let onnxLibFile = null;
            let onnxVersionedFile = null;

            try {
              const files = execSync('ls resources/libonnxruntime.so* 2>/dev/null', { encoding: 'utf8' }).trim().split('\\n');
              onnxLibFile = files.find(f => f.match(/libonnxruntime\\.so$/));
              onnxVersionedFile = files.find(f => f.match(/libonnxruntime\\.so\\./));
            } catch (e) {
              console.log('No ONNX Runtime library files found');
            }

            // Use deb.files to install the binary and ALL libraries to /usr/lib/zigy/
            // The binary uses \$ORIGIN rpath to find the library relative to itself
            const debFiles = {
              '/usr/lib/zigy/zig-april-captions': 'resources/zig-april-captions'
            };

            if (onnxLibFile) {
              debFiles['/usr/lib/zigy/libonnxruntime.so'] = onnxLibFile;
            }
            if (onnxVersionedFile) {
              const version = onnxVersionedFile.match(/libonnxruntime\\.so\\.(.+)/)[1];
              debFiles['/usr/lib/zigy/libonnxruntime.so.' + version] = onnxVersionedFile;
            }

            // NOTE: Not bundling PulseAudio - using system libraries
            // This ensures best compatibility and proper buffer negotiation

            // Note: Model is downloaded for testing but NOT bundled in DEB
            // Users will download model separately
            // try {
            //   const modelFile = execSync('ls resources/*.april 2>/dev/null', { encoding: 'utf8' }).trim();
            //   if (modelFile) {
            //     debFiles['/usr/lib/zigy/resources/' + modelFile.replace('resources/', '')] = modelFile;
            //   }
            // } catch (e) {
            //   console.log('No model file found');
            // }

            config.bundle.linux.deb.files = debFiles;
            // Keep resources empty for deb to avoid conflicts
            config.bundle.resources = [];

            fs.writeFileSync('tauri.conf.json', JSON.stringify(config, null, 2));
            console.log('Updated tauri.conf.json for DEB build');
            console.log('- deb.files:', JSON.stringify(config.bundle.linux.deb, null, 2));
            console.log('- resources: []');
            "
          elif [ "$RUNNER_OS" = "Linux" ] && [ "${{ matrix.bundle }}" = "appimage" ]; then
            # For AppImage: use resources to bundle binary and ALL libraries
            node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('tauri.conf.json', 'utf8'));

            const { execSync } = require('child_process');

            // Use resources to bundle binary + ONNX Runtime into AppImage
            // NOTE: PulseAudio uses system libraries (not bundled) for best compatibility
            const resourceFiles = ['resources/zig-april-captions'];

            // Add all .so files from resources (ONNX Runtime only now)
            try {
              const allLibs = execSync('ls resources/*.so* 2>/dev/null', { encoding: 'utf8' }).trim().split('\\n');
              for (const lib of allLibs) {
                if (lib.length > 0) {
                  // Remove 'resources/' prefix for resource paths
                  const libPath = lib.replace('resources/', '');
                  resourceFiles.push('resources/' + libPath);
                }
              }
            } catch (e) {
              console.log('No library files found');
            }

            config.bundle.resources = resourceFiles;

            fs.writeFileSync('tauri.conf.json', JSON.stringify(config, null, 2));
            console.log('Updated tauri.conf.json for APPIMAGE build');
            console.log('- resources:', JSON.stringify(config.bundle.resources, null, 2));
            "
          elif [ "$RUNNER_OS" = "Windows" ]; then
            # Windows: use resources
            node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('tauri.conf.json', 'utf8'));
            config.bundle.resources = [
              'resources/zig-april-captions.exe',
              'resources/onnxruntime.dll'
            ];
            fs.writeFileSync('tauri.conf.json', JSON.stringify(config, null, 2));
            console.log('Updated tauri.conf.json with Windows resources');
            "
          else
            # macOS: use resources with dylib
            node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('tauri.conf.json', 'utf8'));

            // Find the ONNX Runtime library file names
            const { execSync } = require('child_process');
            let onnxLibFiles = [];

            try {
              const files = execSync('ls resources/libonnxruntime*.dylib 2>/dev/null', { encoding: 'utf8' }).trim().split('\\n');
              onnxLibFiles = files.filter(f => f.match(/libonnxruntime.*\\.dylib$/));
            } catch (e) {
              console.log('No ONNX Runtime library files found');
            }

            // Include executable and all dylib files
            config.bundle.resources = [
              'resources/zig-april-captions',
              ...onnxLibFiles
            ];

            fs.writeFileSync('tauri.conf.json', JSON.stringify(config, null, 2));
            console.log('Updated tauri.conf.json with macOS resources including dylib');
            console.log('Resources:', config.bundle.resources);
            "
          fi
          cat tauri.conf.json

      - name: Update version from git tag
        working-directory: zig-april-captions-ui
        shell: bash
        run: |
          # Extract version from git tag (e.g., v0.2.0 -> 0.2.0)
          VERSION="${GITHUB_REF#refs/tags/v}"
          echo "Updating version to: $VERSION"

          # Update version in package.json
          node -e "
          const fs = require('fs');
          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          pkg.version = '$VERSION';
          fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          console.log('Updated package.json version to $VERSION');
          "

          # Update version in tauri.conf.json
          node -e "
          const fs = require('fs');
          const config = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
          config.version = '$VERSION';
          fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(config, null, 2) + '\n');
          console.log('Updated tauri.conf.json version to $VERSION');
          "

          # Verify the updates
          echo "New version in package.json:"
          cat package.json | grep -A 1 '"version"'
          echo ""
          echo "New version in tauri.conf.json:"
          cat src-tauri/tauri.conf.json | grep -A 1 '"version"'

      - name: Build Tauri App
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MACOSX_DEPLOYMENT_TARGET: "10.13"
          SKIP_ZIG_BUILD: "1"  # Prevent build.rs from rebuilding and overwriting the patched binary
        with:
          releaseId: ${{ needs.create-release.outputs.release_id }}
          args: --target ${{ matrix.target }} --bundles ${{ matrix.bundle }}
          projectPath: zig-april-captions-ui

      - name: Fix rpaths and re-sign binary in macOS DMG
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "Fixing rpaths and re-signing binary in macOS DMG..."

          # Find the built DMG file
          DMG_FILE=$(find zig-april-captions-ui/src-tauri/target -name "*.dmg" -type f | head -1)
          ENTITLEMENTS="zig-april-captions-ui/src-tauri/entitlements.plist"

          if [ -z "$DMG_FILE" ]; then
            echo "No DMG file found (skipping fix)"
            exit 0
          fi

          echo "Found DMG: $DMG_FILE"

          # DMGs are read-only, so we need to:
          # 1. Convert to read-write format
          # 2. Make modifications
          # 3. Convert back to read-only

          # Create a temporary read-write DMG
          TMP_DIR="/tmp/zigy-dmg-fix-$$"
          mkdir -p "$TMP_DIR"
          RW_DMG="$TMP_DIR/temp_rw.dmg"
          MOUNT_POINT="$TMP_DIR/mount"
          mkdir -p "$MOUNT_POINT"

          echo "Converting DMG to read-write format..."
          hdiutil convert "$DMG_FILE" -format UDRW -o "$RW_DMG"

          echo "Mounting read-write DMG..."
          hdiutil attach "$RW_DMG" -mountpoint "$MOUNT_POINT" -nobrowse

          # Find the .app bundle
          APP_BUNDLE=$(find "$MOUNT_POINT" -name "*.app" -maxdepth 1 | head -1)

          if [ -z "$APP_BUNDLE" ]; then
            echo "No .app bundle found in DMG!"
            hdiutil detach "$MOUNT_POINT"
            rm -rf "$TMP_DIR"
            exit 1
          fi

          echo "Found app bundle: $APP_BUNDLE"

          # Fix rpaths on the binary in the mounted DMG
          BINARY="$APP_BUNDLE/Contents/Resources/resources/zig-april-captions"

          if [ -f "$BINARY" ]; then
            echo "Fixing rpaths on: $BINARY"

            # Remove code signature to allow modifications
            codesign --remove-signature "$BINARY" 2>/dev/null || echo "  (no signature to remove)"

            # Remove development rpaths (if any still exist)
            install_name_tool -delete_rpath /opt/homebrew/lib "$BINARY" 2>/dev/null || true
            install_name_tool -delete_rpath /Users/runner/onnxruntime/lib "$BINARY" 2>/dev/null || true
            echo "âœ“ Removed development rpaths"

            # Verify the fix
            echo "Verifying rpaths after fix:"
            otool -l "$BINARY" | grep -A 2 "LC_RPATH" | grep -E "(path|LC_RPATH)"

            # CRITICAL: Re-sign the binary with audio entitlements
            # This is required for macOS to allow microphone access
            # Without this, the spawned binary cannot access audio devices
            echo ""
            echo "Re-signing binary with audio entitlements..."
            codesign --sign - \
              --entitlements "$ENTITLEMENTS" \
              --options=runtime \
              --force \
              --deep \
              "$BINARY"

            echo ""
            echo "Verifying entitlements were applied:"
            codesign -d --entitlements - "$BINARY" 2>&1 | head -20
            echo "âœ“ Binary re-signed with entitlements"
          else
            echo "Binary not found at: $BINARY"
          fi

          # Unmount the read-write DMG
          echo "Unmounting..."
          hdiutil detach "$MOUNT_POINT"

          # Convert back to read-only compressed DMG
          echo "Converting back to compressed read-only DMG..."
          rm "$DMG_FILE"
          hdiutil convert "$RW_DMG" -format UDZO -o "$DMG_FILE"

          # Cleanup
          rm -rf "$TMP_DIR"
          echo "âœ“ Fixed rpaths and re-signed binary in DMG"

      - name: Final Verification - Inspect DMG/App Bundle (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "=========================================="
          echo "Final DMG/App Bundle Verification (macOS)"
          echo "=========================================="

          # Find the built DMG file
          DMG_FILE=$(find zig-april-captions-ui/src-tauri/target -name "*.dmg" -type f | head -1)

          if [ -z "$DMG_FILE" ]; then
            echo "ERROR: No DMG file found!"
            exit 1
          fi

          echo "Found DMG: $DMG_FILE"
          echo ""

          # Mount the DMG
          echo "Mounting DMG..."
          MOUNT_POINT="/tmp/zigy-verify-$$"
          mkdir -p "$MOUNT_POINT"
          hdiutil attach "$DMG_FILE" -readonly -mountpoint "$MOUNT_POINT" -nobrowse

          # Find the .app bundle
          APP_BUNDLE=$(find "$MOUNT_POINT" -name "*.app" -maxdepth 1 | head -1)

          if [ -z "$APP_BUNDLE" ]; then
            echo "ERROR: No .app bundle found in DMG!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          echo "Found app bundle: $APP_BUNDLE"
          echo ""

          # Path to the binary inside the app
          BINARY="$APP_BUNDLE/Contents/Resources/resources/zig-april-captions"

          if [ ! -f "$BINARY" ]; then
            echo "ERROR: Binary not found at: $BINARY"
            echo "Contents of Resources/resources:"
            ls -la "$APP_BUNDLE/Contents/Resources/resources/" || echo "Directory not found"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          echo "1. Files in app bundle:"
          echo ""
          echo "Resources/resources:"
          ls -lah "$APP_BUNDLE/Contents/Resources/resources/" 2>/dev/null || echo "  (empty or doesn't exist)"
          echo ""
          echo "Frameworks:"
          ls -lah "$APP_BUNDLE/Contents/Frameworks/" 2>/dev/null || echo "  (empty or doesn't exist)"
          echo ""

          echo "2. Binary rpaths in final app:"
          otool -l "$BINARY" | grep -A 3 "LC_RPATH"
          echo ""

          echo "3. Binary library dependencies:"
          echo "ONNX Runtime:"
          otool -L "$BINARY" | grep -i onnx || echo "  (not found)"
          echo "PulseAudio:"
          otool -L "$BINARY" | grep -i pulse || echo "  (not found - expected on macOS)"
          echo ""

          echo "4. Checking dylib files exist:"
          RESOURCES_PATH="$APP_BUNDLE/Contents/Resources/resources"
          FRAMEWORKS_PATH="$APP_BUNDLE/Contents/Frameworks"

          # Check ONNX Runtime (in Frameworks)
          if [ -f "$FRAMEWORKS_PATH/libonnxruntime.1.16.3.dylib" ]; then
            echo "âœ“ libonnxruntime.1.16.3.dylib exists (in Frameworks)"
            otool -D "$FRAMEWORKS_PATH/libonnxruntime.1.16.3.dylib" | tail -1
          else
            echo "ERROR: libonnxruntime.1.16.3.dylib not found in Frameworks!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          echo "4. Final check - No hardcoded paths:"
          echo "Checking for /opt/homebrew paths:"
          if otool -L "$BINARY" | grep "/opt/homebrew"; then
            echo "ERROR: Found hardcoded Homebrew paths in final DMG!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          else
            echo "âœ“ No /opt/homebrew paths"
          fi
          echo "Checking for GitHub Actions paths:"
          if otool -l "$BINARY" | grep -i "runner/work"; then
            echo "ERROR: Found hardcoded GitHub Actions paths in final DMG!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          else
            echo "âœ“ No hardcoded paths found"
          fi
          echo ""

          echo "5. Verify required rpaths present in final app:"
          RPATH_OUTPUT=$(otool -l "$BINARY" | grep -A 2 "LC_RPATH")

          if echo "$RPATH_OUTPUT" | grep -q "@executable_path/../../Frameworks"; then
            echo "âœ“ Found @executable_path/../../Frameworks"
          else
            echo "ERROR: Missing @executable_path/../../Frameworks in final app!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          if echo "$RPATH_OUTPUT" | grep "@executable_path" | grep -v "Frameworks" > /dev/null; then
            echo "âœ“ Found @executable_path (for ONNX Runtime in Resources)"
          else
            echo "ERROR: Missing @executable_path in final app!"
            hdiutil detach "$MOUNT_POINT"
            exit 1
          fi

          echo ""
          echo "6. CRITICAL: Verify audio entitlements are present:"
          echo "This is required for the app to access the microphone!"
          ENTITLEMENTS_OUTPUT=$(codesign -d --entitlements - "$BINARY" 2>&1)
          echo "$ENTITLEMENTS_OUTPUT" | head -30

          if echo "$ENTITLEMENTS_OUTPUT" | grep -q "com.apple.security.device.audio-input"; then
            echo "âœ“ Audio input entitlement found (com.apple.security.device.audio-input)"
          else
            echo "WARNING: Audio entitlement not found in binary!"
            echo "The app may not be able to access the microphone."
            echo "Users may see 'Failed to get default input device' error."
            # Don't fail the build, but warn loudly
          fi

          # Unmount DMG
          echo ""
          echo "Unmounting DMG..."
          hdiutil detach "$MOUNT_POINT"

          echo ""
          echo "=========================================="
          echo "âœ“ Final DMG Verification Passed!"
          echo "=========================================="

  publish-release:
    needs: [create-release, build-tauri]
    runs-on: ubuntu-latest
    steps:
      - name: Publish Release
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: ${{ needs.create-release.outputs.release_id }},
              draft: false
            })
